import type { RestTransportOptions } from '../../types'
import type { GetContentsDataType } from '../types'
import { puts } from '../utils'

export function getServerDeclarationContents({ nuxt, options }: GetContentsDataType): string {
  const transports = options?.transports
  const noRest = !transports?.rest || ''
  const exp = (transports?.rest as RestTransportOptions).framework === 'express' || ''
  const koa = (transports?.rest as RestTransportOptions).framework === 'koa' || ''

  return `// ! Generated by nuxt-feathers - do not change manually
import type { ${noRest && `Application as FeathersApplication, `}HookContext as FeathersHookContext, NextFunction } from '@feathersjs/feathers'
${puts([
  [koa, `import type { Application as FeathersApplication } from '@feathersjs/koa'`],
  [exp, `import type { Application as FeathersApplication } from '@feathersjs/express'`],
])}
import type { NitroApp } from 'nitropack'

export type { NextFunction }

export interface Configuration {
  framework?: 'express' | 'koa' | undefined
  websocket?: boolean
}

// A mapping of service names to types. Will be extended in service files.
export interface ServiceTypes {}

export interface ApplicationAddons {
  nitroApp?: NitroApp
}

// The application instance type that will be used everywhere else
export type Application = FeathersApplication<ServiceTypes, Configuration> & ApplicationAddons

// The context for hook functions - can be typed with a service class
export type HookContext<S = any> = FeathersHookContext<Application, S>
`
}
